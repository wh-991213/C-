#include<stdio.h>

int main0401(void)
{
	//原码：一个数的原码(原始的二进制码)有如下特点：
	//最高位做为符号位，0正，1负
	//其它数值部分就是数值本身绝对值的二进制数
	//负数的原码是在其绝对值的基础上，最高位变为1
	//原码不能加减运算，为什么呢？？

	/*
	1-1
	1+(-1)
	错误算法：
	1的原码  0000 0001
	-1的原码 1000 0001
		结果 1000 0010  对应十进制130


	正确算法：
	1的原码、反码、补码 0000 0001
	            -1的原码1000 0001
					反码1111 1110
					补码1111 1111
					结果10000 0000
		      舍去最高位0000 0000对应十进制为0
	*/

	//下面说一下正数和负数对于原码、反码、补码之间的转换
	//对于正数，原码、反码、补码相同
	//对于负数的原码，其反码符号位不变，其它部分取反；其补码为反码+1
	//计算机中数值使用补码来存储

	//从计算机的内部工作原理，实际上是没有减法这一说法的，只能转换成 10+(-10)
	//eg:
	int a = 76;
	int b = 32;
	int sum = a - b;
	/*
	76+(-32)
	76的原码、反码、补码相同 0100 1100
	               -32的原码 1010 0000
		                反码 1101 1111
		                补码 1110 0000
						结果 10010 1100
				  舍去最高位 0010 1100 这里是正数，三码一致，所以对应十进制为44（如果是负数就要反推成原码才能得到对应的十进制）


	*/
	printf("%d\n", sum);//44（转成二进制就是它的原码）

	/*
	76-82
	76+(-82)
	76的原码、反码、补码相同 0100 1100
	               -82的原码 1101 0010
						反码 1010 1101
						补码 1010 1110
						结果 1111 1010(这里要求出对应的十进制结果需要求出原码)
					反推反码 1111 1001
						原码 1000 0110 对应的十进制为-6

	*/
	//在计算机中，数值为什么一律使用补码来计算存储？？
	//1.统一了零的编码
	//2.将符号位和其它位统一处理
	//3.将减法运算转变为加法运算
	//4.两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃
	return 0;
}