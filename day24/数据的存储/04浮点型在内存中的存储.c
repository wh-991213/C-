#include<stdio.h>
#include<float.h>

int main0401()
{
	//常见的浮点数：float、double、long double
	//使用float.h查看浮点型的取值范围，格式如下
	DBL_DIG;//double精度
	DBL_MAX;
	FLT_DIG;//float精度
	FLT_MAX;
	return 0;
}

int main0402()
{
	//以整型的方式放进内存，以整型的方式拿出来是没问题的，但以浮点型的方式拿出来却与预想不符；
	//以浮点型的方式放内存，以浮点型的方式拿出来是没问题的，但以整型的方式拿出来却与预想不符；
	//请先看完下面再看解题过程
	int n = 9;
	//00000000 00000000 00000000 00001001 - 补 
	//%d: - 9
	//%f:
	//0 00000000 00000000000000000001001
	//(-1)^0 * 0.00000000000000000001001 * 2^-126
	float *pFloat = (float*)&n;//同char*p=(char*)&n;
	printf("n的值为:%d\n", n);//9
	printf("*pFloat的值为:%f\n", *pFloat);//0.000000
	//-------------------------------------------------------------------------------
	//%f:9.000000
	//9.0:%d
	//1001.0
	//(-1)^0 * 1.001 * 2^3
	//0 3+127 001
	//0 10000010 00100000000000000000000
	//将它转成10进制发现它与结果相匹配
	*pFloat = 9.0;
	printf("num的值为:%d\n", n);//1091567616
	printf("*pFloat的值为:%f\n",*pFloat);//9.000000

	//说明整型与浮点型在内存中的存储是有区别的 
	//对于整型：二进制的补码，且有大小端之分
	//对于浮点型：
	//根据国际标准IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成以下形式
	//1.(-1)^S * M * 2^E 
	//2.(-1)^S表示符号位，当S=0,V为正数；当S=1,V为负数
	//3.M表示有效数字，大于等于1，小于2
	//4.2^E表示指数位 
	//IEEE 754规定：对于32位(float)的浮点数，最高的1位是符号位S,接着的8位是指数E(没有符号位的概念),剩下的23位为有效数字M
	//S E E E E E E E E M M M M M M M M M M M M M M M M M M M M M M M - float存储模型
	//对于64位(double)，最高的1位是符号位S，接着的11位是指数E(没有符号位的概念)，剩下的52位为有效数字M
	//S E E E E E E E E E E E M M M M M M M M M M M M M M M M M M M M ... ... - double存储模型

	//之前说过1<=M<2,也就是说M可以写成1.xxxx形式，其中xxxx代表小数部分
	/*IEEE754规定，在计算机内部存储M时，默认的这个数的第一位总是1，因此将它舍去，只保留后面的 xxxx部分。如1.01 -> 01
	等读取时，再加上第一位的1。这样做的目的是节省一位有效数字，以32位为例，有效位可以保存24位数字，提升了精度*/

	//而至于指数E是unsigned。如果E为8位，它的取值范围为0-255；如果E为11位，它的取值范围为0-2047。
	//因为科学计数法中的E是可以出现负数的，所以IEEE754规定，存入内存时E的真实值必须加上一个中间值。
	//对于32位，这个中间值是127；对于64位，这个中间值是1023。如：2^10的E是10，所以保存32位浮点数时，必须保存成10+127=137 -> 10001001
	//eg:
	//0.5
	//0.1 - 0.5的二进制 0*2^0.1*2^-1
	//(-1)^0*1.0*2^-1
	//指数E：-1 
	//-1+127=126 - 因为是unsigned所以这是内存中的值，如果E是正数也要加上这个中间值
	//然真实的值就是126-127=-1


	return 0;
}

//测试IEEE 754规定的浮点型存储模式
int main0403()
{
	float f = 5.5;
	//5.5
	//101.1
	//(-1)^0*1.011*2^2
	//S=0
	//M=1.011
	//E=2
	//0          2+127           011
	//0          10000001        01100000000000000000000
	//		|				|
	//		|				|
	//0100 0000 1011 0000 0000 0000	0000 0000
	//0x40b00000 - 这是放进去的值
	//调试后在内存中成功验证了结果 

	//然后指数E从内存中取出来还可以分为三种情况：
	//一、E不为全0或E不为全1
	//即指数E的计算值减去127/1023,得到真实值；再将有效数字M前加上一位1
	//就如上面的5.5
	//(-1)^0*1.011*2^2 - 还原后
	//二、E全为0
	//说明E的真实值是-127
	//E=-127
	//(+ -)1.xx*2^-127  ->  (+ -)1.xx/2^127  ->  所想表达的是正负无限趋向于0的数字
	//这时，浮点数的指数E等于1-127/1-1023即为真实值，有效数字M不再加上1而是还原为0.xxx的小数，这样做是为了表示+-0,以及接近于0很小的数字 
	//eg:0 00000000 01100000000000000000000
	//+/- 0.011*2^-126 - 也是一个无限接近于0的数字
	//三、E全为1
	//0 11111111 01100000000000000000000
	//E+127=255 -> E=128
	//(+ -)1.xx*2^128 - 表示的是正负无穷大的数字
	
	return 0;
}