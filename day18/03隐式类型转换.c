#include<stdio.h>

int main0701()
{
	//为了获得这个精度，表达式中的字符和整型操作数在使用之前被转换为普通整型，这种转换称为整型提升；
	//b和c的值被提升为普通整型，然后再执行加法运算;加法运算完成之后，结果将被截断，然后再存储c中
	char a = 3;
	//3是整型类型
	//00000000 00000000 00000000 00000011
	//放到字符型里（最低位1个字节的内容）
	//00000011 - 这是a里放的
	char b = 127;
	//00000000 00000000 00000000 01111111
	//截取后
	//01111111 - 这里b里放的
	char c = a + b;
	//a和b如何相加呢
	//如何进行整型提升 - 整型提升是按照变量的数据类型的符号位来提升的
	//字符型 - 整型
	//00000000 00000000 00000000 00000011 - a
	//00000000 00000000 00000000 01111111 - b
	//00000000 00000000 00000000 10000010 - a+b
	//再截取
	//10000010 - c
	//再提升
	//11111111 11111111 11111111 10000010 - 补码
	//11111111 11111111 11111111 10000001 - 反码
	//10000000 00000000 00000000 01111110 - 原码
	//-126
	printf("%d\n", c);
	//结果是-126 
	return 0;
	//整型提升的意义：
	/*表达式整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节
	长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要转换为CPU内整型
	操作数的标准长度*/
	/*通用CPU是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这样字节的相加指令）。
	所以，表达式中各种长度可能小于int长度的整型值，都必须先转为int或unsigned int
	然后才能送往CPU去执行运算*/
}


int main0702(void)
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	//这里只打印了c（这里c没有整型提升）
	//为什么没打印a、b？？？
	//10110110 - a
	//11111111 11111111 11111111 10110110 - a整型提升后
	//显然两都不相等；同理short b也是
	return 0;
}

int main0703(void)
{
	char c = 1;
	printf("%u\n", sizeof(c));//1
	printf("%u\n", sizeof(+c));//4
	//c只要参与表达式运算，就会发生整型提升；所以sizeof(+c)是4个字节 
	printf("%u\n", sizeof(!c));//1
	return 0;
}