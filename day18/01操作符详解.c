#include<stdio.h>

//算术操作符
int main0101()
{
	// /除法；得到的是商
	int a = 5 / 2;
	printf("a=%d\n", a);

	// %取模；得到的是余数
	int b = 5 % 2;
	printf("b=%d\n", b);
	return 0;
}

//移位操作符  移动的是二进制位	
//警告：对于移位运算符，不要移动负数位，这个是标准未定义的。且他们的操作必须是整数
//例如:int num=10;
//num>>-1;
int main0102(void)
{
	//右移操作符可以分为
	//1.算术右移：右边丢弃，左边补原符号位
	//2.逻辑右位：右边丢弃，左边补0
	int a = 16;
	//16对应的二进制为00000000 00000000 00000000 00010000
	//            右移00000000 00000000 00000000 00001000对应的十进制为8
	int b = a >> 1;
	printf("%d\n", a);
	printf("%d\n", b);

	//思考上面是属于算术右移还是逻辑右移，这里我们发现上面是正数，无论是算术右移还是逻辑右移结果是一样的。所以这里使用负数测试
	int c = -1;
	//整数的二进制表示有：原码、反码、补码
	//存储到内存的是补码，移的也是补码，所以要得到补码
	//-1的原码：10000000 00000000 00000000 00000001
	//    反码：11111111 11111111 11111111 11111110
	//    补码：11111111 11111111 11111111 11111111
	//右移一位：11111111 11111111 11111111 11111111
	int d = c >> 1;
	printf("%d\n", d);
	//这里的还是-1，所以这里是算术移位。也证实了当前的编译器的采用的是算术移位
	return 0;
}
int main0103(void)
{
	//左移操作符
	//左边丢弃，右边补0
	int a = 5;
	int b = a << 1;
	//00000000 00000000 00000000 00000101
	//00000000 00000000 00000000 00001010   十进制为8
	printf("%d\n", b);
	return 0;
}

int main0104(void)
{
	//&:按位与(二进制位)同真为真，其余为假；注意区分逻辑与&&
	int a = 3;
	int b = 5;
	int c = a & b;
	//00000000 00000000 00000000 00000011 
	//00000000 00000000 00000000 00000101
	//00000000 00000000 00000000 00000001
	//注意如果是负数一定要转化成补码再按位与
	printf("%d\n", c);
	return 0;
}
int main0105(void)
{
	//|:按位或(二进制位)同假为假，其余为真；注意区分逻辑或
	int a = 3;
	int b = 5;
	int c = a | b;
	//00000000 00000000 00000000 00000011 
	//00000000 00000000 00000000 00000101
	//00000000 00000000 00000000 00000111
	printf("%d\n",c);
	return 0;
}
int main0106(void)
{
	//^:按位异或(二进制位)；相同为0，相异为1
	int a = 3;
	int b = 5;
	int c = a ^ b;
	//00000000 00000000 00000000 00000011 
	//00000000 00000000 00000000 00000101
	//00000000 00000000 00000000 00000110
	printf("%d\n", c);
	return 0;
}
//赋值操作符
int main0107(void)
{
	//赋值操作符可以连续使用
	int a = 10;
	int x = 0;
	int y = 20;
	//连续赋值(不推荐)
	//a = x = y;
	//一般是分开写，更清晰明了
	x = y;
	a = x;
	return 0;
}
