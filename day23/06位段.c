#include<stdio.h>


//位段 - 二进制位
struct S
{
	int a : 2;//a对应2个二进制位
	int b : 5;
	int c : 10;
	int d : 30;
	//总共47bit   6B*8=48bit
};
int main0601()
{
	struct S s;
	printf("%d\n",sizeof(s));//8Byte - 与预想不符
	return 0;
}
//探讨 - 位段内存分配
//1.位段的成员一般可以是int 、unsigned int、signed int 或者是char、short(属于整型家庭)的类型 - 位段的成员通常都是相同的类型
//2.位段的空间是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的
//3.位段涉及很多不确定的因素，位段是不跨平台的，注重可移植的程序应该避免使用位段 - 虽然位段能够节省空间，但是它也会带来一些问题

//为什么开辟8个字节的空间？？？
//这里位段每次是按照一个整型int大小来开辟空间  1Byte=8bit   4Byte=32bit  
//(先开辟int - 4个字节空间)a a b b b b b c c c c c c c c c c (这里不够存储d，浪费了15bit空间)(重新开辟4个字节存储d并浪费2bit的空间)
//总共开辟了8个字节


//注意：这里每个位段不能大于4个字节，也就是32bit，如果>32 - err
//位段or结构体  - 空间浪费？？？
//事实上位段更节省空间
//如果这里不使用位段，而使用结构体。就占16个字节的空间   16Byte  or  8Byte




struct S1
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};

int main0602(void)
{
	struct S1 s = { 0 };
	//以下变量的二进制
	s.a = 10;// 1010
	s.b = 20;//10100
	s.c = 3;//011
	s.d = 4; //100
	printf("%d\n", sizeof(s));
	//这里有个问题，位段在内存中的布局 - 这里没有一个明确的标准 - 所以说位段涉及很多不确定的因素 - 所以说位段是不跨平台的
	//0 b b b b a a a | 0 0 0 c c c c c | 0 0 0 0 d d d d  - 先初始化为0 
	//		 ||				   ||				 ||
	//		 ||				   ||				 ||
	//0 0 1 0 0 0 1 0 | 0 0 0 0 0 0 1 1 | 0 0 0 0 0 1 0 0 - 将变量初始化为对应数字(多则省略，少则补0)
	//		 ||				   ||				 ||
	//		 ||				   ||				 ||
	//验证是不是在内存中这样放 - 如果要观察的话它是以十六进制的方式展示 - 先转化成十六进制(4个二进制位是1个十六进制位)
	//		 22		  |		   03		|		 04	      - 如果内存中的布局是这样的话，那看到的将是22 03 04
	//		 ||				   ||                ||
	//		 ||				   ||				 ||
	//验证方式：调试 - 打开内存 - &s - 最后证实了位段在VS2017IDE中的布局是这样的
	return 0;
}
//以上可以了解当前VS2017中存储方式
/*从右到左，从低位到高位，当系统发现当前开辟空间里剩下的bit不能满足下一个需要的内存空间大小，
系统会将当前开辟空间里剩下的bit浪费掉，然后重新开辟空间，下一个内存空间依旧从右到左，
从低位到高位；整体是从左到右*/

//位段的跨平台问题
//1.int位段被当成有符号数还是无符号数是不确定的
//2.位段中最大的数目不能确定，(16位最大16，32位最大32。比如在32位里写30位，放到16位机器里会出问题)
//3.位段中的成员在内存中从左向右分配还是从右到左分配标准尚未定义 
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩于的位时，是舍弃剩余的位还是利用，这是不确定的
//虽然在本编译器上已经证实了一些问题，但其它编译器不一定是这样处理的

//总结：
//跟结构体相比，位段除了可以达到同样的效果，还可以更好的节省空间，但是有跨平台的问题存在