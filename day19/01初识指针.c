#include<stdio.h>

int main0101()
{
	int a = 10;
	int* p = &a;//p就是一个指针变量，存放a的地址
	return 0;
	//一个地址单元是一个字节
	//内存单元产生的地址是如何编址？？？
	//对于32位的机器，假设有32根地址线，那么每根地址线在寻址的时候产生一个电信号（正电/负电），也就是1或0
	//那么32根地址线产生的地址序列
	//00000000 00000000 00000000 00000000
	//00000000 00000000 00000000 00000001 
	//... ...
	//11111111 11111111 11111111 11111111
	//这里就有2的32次方个地址
	//每个地址标识一个字节，那么：
	//2^32Byte = 2^32/1024kb = 2^32/1024/1024MB = 2^32/1024/1024/1024GB = 4GB
	//64位同理
}

int main0102(void)
{
	//printf("%d\n", sizeof(int*));
	//printf("%d\n", sizeof(char*));
	//printf("%d\n", sizeof(short*));
	//这里所有指针类型所占内存大小为4B或8B。在x86(32位)下是4个字节；在x64(64位)下是8个字节

	int a = 0x11223344;
	int* pa = &a;
	char* pc = &a;
	printf("%p\n", pa);
	printf("%p\n", pc);
	//虽然pc这里会报一个不兼容警告，但是pa和pc的地址是一样的，可见不管是什么类型的都能存放a的地址
	return 0;
}

//既然指针大小都是4个字节或8个字节，为什么还要区分类型呢？？？
//意义1:
int main0103(void)
{
	int a = 0x11223344;
	//1
	//int* pa = &a;//44 33 22 11
	//*pa = 0;//00 00 00 00
	//从内存中发现通过*pa=0改变了内存里存放的4个字节

	//2
	double* pc = &a;
	*pc = 0;//00 33 22 11
	//发现内存里的4个字节，通过*pc=0仅仅只操作了1个字节

	//这就是指针类型不同的区别
	//当不同的指针类型去存储数据时，它是可以存储数据的；指针类型决定了指针进行解引用操作的时候，能够访问空间的大小
	return 0;
}
//意义2:
int main0104(void)
{
	int a = 0x11223344;
	//1
	int* pa = &a;
	printf("%p\n", pa);
	printf("%p\n", pa+1);
	//相差4字字节

	//2
	char* pc = &a;
	printf("%p\n", pc);
	printf("%p\n", pc+1);
	//相差1字字节

	//指针类型决定了指针走一步走多远（指针的步长）
	return 0;
}

//这2个意义有什么价值？？？
int main0105(void)
{
	int arr[10] = { 0 }; 
	int* p = arr;
	//char* p = arr;//这里换成char*类型，程序结束后依然能打印10个1，但是真正的操作的是2个半整型字节
	//这里要把数组里存放的0全部改成1
	for (int i = 0; i < 10; i++)
	{
		*(p + i) = 1;
		printf("%d\n", *p);
	}
	return 0;
}

//野指针
//野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
//哪些原因可能导致野指针呢？？？
//1未初始化
int main0106(void)
{
	//int a;//局部变量未初始化，默认是随机值 
	int* p;//局部指针变量未初始化，会被初始化随机值
	//如果访问内存空间时
	//*p = 20;
	return 0;
}
//2指针越界访问
int main0107(void)
{
	int arr[10] = { 0 };
	int* p = arr;
	for (int i = 0; i < 12; i++)
	{
		p++;
	}
	return 0;
}
//3指针指向的空间释放（了解一下，动态内存开辟的时候再细讲）
int* test()
{
	int a = 10;//局部变量出了这个范围后就销毁了，销毁后a对应的内存空间就不是存放a的值了
	//return &a;
}
int main0108(void)
{
	int* p = test();
	*p = 20;//访问的空间不是当前程序的；它指向已经被释放的内存
	return 0;
}
//如何规避野指针
//指针初始化
//小心指针越界
//指针指向空间释放即设置NULL - int* p = NULL;当你不知道将它赋什么值的情况，为避免野指针，可以将它赋给空指针
//指针使用之前检查有效性

int main0109(void)
{
	int a = 10;
	int* pa = &a;
	*pa = 20;
	pa = NULL;
	if (pa != NULL)
	{
		//这里就可以加一个判断，目的是为了合法
	}
	return 0;
}